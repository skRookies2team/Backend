package com.story.game.creation.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.story.game.ai.dto.NovelStyleLearnRequestDto;
import com.story.game.ai.service.RelayServerClient;
import com.story.game.creation.dto.*;
import com.story.game.common.dto.*;
import com.story.game.creation.entity.StoryCreation;
import com.story.game.common.entity.StoryData;
import com.story.game.creation.repository.StoryCreationRepository;
import com.story.game.common.repository.StoryDataRepository;
import com.story.game.infrastructure.s3.S3Service;
import com.story.game.rag.dto.CharacterIndexRequestDto;
import com.story.game.rag.dto.NovelIndexRequestDto;
import com.story.game.rag.service.RagService;
import jakarta.persistence.EntityNotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class StoryManagementService {

    private final StoryCreationRepository storyCreationRepository;
    private final RagService ragService;
    private final StoryDataRepository storyDataRepository;
    private final WebClient relayServerWebClient;
    private final RelayServerClient relayServerClient;
    private final ObjectMapper objectMapper;
    private final S3Service s3Service;
    private final com.story.game.story.repository.EpisodeRepository episodeRepository;

    @org.springframework.beans.factory.annotation.Value("${aws.s3.bucket}")
    private String bucketName;

    @Transactional
    public StoryUploadResponseDto uploadNovel(StoryUploadRequestDto request, com.story.game.auth.entity.User user) {
        log.info("=== Upload Novel ===");
        log.info("Title: {}, User: {}", request.getTitle(), user != null ? user.getUsername() : "null");

        String storyId = "story_" + UUID.randomUUID().toString().substring(0, 8);

        StoryCreation storyCreation = StoryCreation.builder()
                .id(storyId)
                .user(user)
                .title(request.getTitle())
                .genre(request.getGenre())
                .novelText(request.getNovelText())
                .status(StoryCreation.CreationStatus.ANALYZING)
                .currentPhase("ANALYZING")
                .progressPercentage(0)
                .progressMessage("Starting novel analysis...")
                .build();

        storyCreation = storyCreationRepository.save(storyCreation);

        // Upload novel to S3 first (for AI-IMAGE server)
        String novelFileKey = "novels/original/" + storyId + ".txt";
        s3Service.uploadFile(novelFileKey, request.getNovelText());
        log.info("Uploaded novel to S3: {}", novelFileKey);

        // Generate thumbnail synchronously
        String thumbnailImageUrl = null;
        String thumbnailFileKey = "thumbnails/" + storyId + "/thumbnail.png";
        try {
            // Generate presigned URL for thumbnail upload
            String thumbnailS3Url = s3Service.generatePresignedUploadUrl(thumbnailFileKey).getUrl();
            log.info("Generated presigned URL for thumbnail upload: {}", thumbnailFileKey);

            // Call AI-IMAGE server to learn style and generate thumbnail
            com.story.game.ai.dto.NovelStyleLearnRequestDto learnRequest = com.story.game.ai.dto.NovelStyleLearnRequestDto.builder()
                    .story_id(storyId)
                    .title(request.getTitle())
                    .novel_s3_bucket(bucketName)
                    .novel_s3_key(novelFileKey)
                    .thumbnail_s3_url(thumbnailS3Url)
                    .thumbnail_s3_bucket(bucketName)  // Ï∂îÍ∞Ä
                    .thumbnail_s3_key(thumbnailFileKey)  // Ï∂îÍ∞Ä
                    .build();

            // ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä
            log.info("üìã Thumbnail request details:");
            log.info("   thumbnail_s3_url: {}", thumbnailS3Url != null ? "SET (length: " + thumbnailS3Url.length() + ")" : "NULL");
            log.info("   thumbnail_s3_bucket: {}", bucketName);
            log.info("   thumbnail_s3_key: {}", thumbnailFileKey);

            // Synchronous call to learn style and generate thumbnail
            com.story.game.ai.dto.NovelStyleLearnResponseDto learnResponse = relayServerClient.learnNovelStyle(learnRequest);
            if (learnResponse != null && learnResponse.getThumbnail_image_url() != null) {
                log.info("Thumbnail generated by AI-IMAGE server: {}", learnResponse.getThumbnail_image_url());

                // Generate presigned download URL for the thumbnail
                thumbnailImageUrl = s3Service.generatePresignedDownloadUrl(thumbnailFileKey);
                log.info("‚úÖ Generated presigned download URL for thumbnail: {}",
                    thumbnailImageUrl.substring(0, Math.min(100, thumbnailImageUrl.length())) + "...");

                // Save thumbnail file key to StoryCreation
                storyCreation.setThumbnailFileKey(thumbnailFileKey);
                storyCreationRepository.save(storyCreation);
                log.info("‚úÖ Saved thumbnail fileKey to DB: {}", thumbnailFileKey);
            } else {
                log.warn("No thumbnail URL in response from AI-IMAGE server");
            }
        } catch (Exception e) {
            log.error("Failed to generate thumbnail: {}", e.getMessage(), e);
            // Continue without thumbnail
        }

        // Start AI analysis async
        startAnalysisAsync(storyId, request.getNovelText());

        return StoryUploadResponseDto.builder()
                .storyId(storyCreation.getId())
                .title(storyCreation.getTitle())
                .genre(storyCreation.getGenre())
                .status(storyCreation.getStatus())
                .createdAt(storyCreation.getCreatedAt())
                .thumbnailImageUrl(thumbnailImageUrl)
                .build();
    }

    @Transactional
    public void startAnalysisAsync(String storyId, String novelText) {
        try {
            log.info("Starting AI analysis for story: {}", storyId);
            log.info("Novel text parameter - is null: {}, length: {}",
                novelText == null,
                novelText != null ? novelText.length() : 0);

            // Upload novel text to S3 for RAG access
            String novelFileKey = "novels/original/" + storyId + ".txt";
            s3Service.uploadFile(novelFileKey, novelText);
            log.info("Uploaded original novel to S3: {}", novelFileKey);

            // Generate pre-signed download URL for RAG server
            String novelDownloadUrl = s3Service.generatePresignedDownloadUrl(novelFileKey);
            log.info("Generated Pre-signed download URL for RAG server: {}", novelFileKey);

            // Index novel to RAG server (Î≥ëÎ†¨ Ï≤òÎ¶¨ - Ïã§Ìå®Ìï¥ÎèÑ Î∂ÑÏÑù Í≥ÑÏÜç ÏßÑÌñâ)
            StoryCreation storyCreationForRag = storyCreationRepository.findById(storyId)
                    .orElseThrow(() -> new RuntimeException("Story not found"));
            NovelIndexRequestDto ragRequest = NovelIndexRequestDto.builder()
                    .storyId(storyId)
                    .title(storyCreationForRag.getTitle())
                    .fileKey(novelFileKey)
                    .bucket(bucketName)
                    .build();
            ragService.indexNovel(ragRequest);

            NovelAnalysisRequestDto request = NovelAnalysisRequestDto.builder()
                    .novelText(novelText)
                    .fileKey(novelFileKey)  // S3 ÌååÏùº ÌÇ§ÎèÑ Ìï®Íªò Ï†ÑÎã¨
                    .bucket(bucketName)
                    .novelDownloadUrl(novelDownloadUrl)  // RAGÍ∞Ä ÏõêÎ≥∏ ÏÜåÏÑ§ÏùÑ Îã§Ïö¥Î°úÎìúÌï† URL
                    .build();

            log.info("Created NovelAnalysisRequestDto - novelText field is null: {}, length: {}",
                request.getNovelText() == null,
                request.getNovelText() != null ? request.getNovelText().length() : 0);

            try {
                String requestJson = objectMapper.writeValueAsString(request);
                log.info("Serialized JSON to send to relay-server: {}",
                    requestJson.length() > 500 ? requestJson.substring(0, 500) + "..." : requestJson);
            } catch (Exception e) {
                log.warn("Failed to serialize request for logging", e);
            }

            NovelAnalysisResponseDto response = relayServerWebClient.post()
                    .uri("/ai/analyze")
                    .bodyValue(request)
                    .retrieve()
                    .bodyToMono(NovelAnalysisResponseDto.class)
                    .block();

            if (response == null) {
                throw new com.story.game.common.exception.ExternalServiceException("No response from AI server");
            }

            StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                    .orElseThrow(() -> new RuntimeException("Story not found"));

            storyCreation.setSummary(response.getSummary());
            storyCreation.setCharactersJson(objectMapper.writeValueAsString(response.getCharacters()));
            storyCreation.setGaugesJson(objectMapper.writeValueAsString(response.getGauges()));
            storyCreation.setS3FileKey(novelFileKey);  // Save original novel S3 key
            // Note: finalEndings will be generated after user selects gauges (in selectGauges method)
            storyCreation.setStatus(StoryCreation.CreationStatus.GAUGES_READY);
            storyCreation.setCurrentPhase("GAUGES_READY");
            storyCreation.setProgressPercentage(30);
            storyCreation.setProgressMessage("Novel analysis completed");

            storyCreationRepository.save(storyCreation);

            log.info("AI analysis completed for story: {}", storyId);

            // Learn novel style for image generation (non-blocking, failure is non-critical)
            try {
                NovelStyleLearnRequestDto styleRequest = NovelStyleLearnRequestDto.builder()
                        .story_id(storyId)
                        .novel_text(novelText)
                        .title(storyCreation.getTitle())
                        .build();

                com.story.game.ai.dto.NovelStyleLearnResponseDto styleResult = relayServerClient.learnNovelStyle(styleRequest);
                if (styleResult != null) {
                    log.info("Novel style learned successfully for story: {}", storyId);
                } else {
                    log.warn("Novel style learning failed for story: {} (non-critical)", storyId);
                }
            } catch (Exception e) {
                log.warn("Failed to learn novel style (non-critical): {}", e.getMessage());
            }
        } catch (Exception e) {
            log.error("Failed to analyze novel for story: {}", storyId, e);
            updateStoryStatus(storyId, StoryCreation.CreationStatus.FAILED, "Analysis failed: " + e.getMessage());
        }
    }

    @Transactional(readOnly = true)
    public StorySummaryResponseDto getSummary(String storyId) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        String summary = null;

        if (storyCreation.getAnalysisResultFileKey() != null && !storyCreation.getAnalysisResultFileKey().isBlank()) {
            try {
                String analysisJson = s3Service.downloadFileContent(storyCreation.getAnalysisResultFileKey());
                NovelAnalysisResponseDto analysisData = objectMapper.readValue(analysisJson, NovelAnalysisResponseDto.class);
                summary = analysisData.getSummary();
            } catch (Exception e) {
                log.error("Failed to download analysis result from S3: {}", storyCreation.getAnalysisResultFileKey(), e);
            }
        }
        else {
            summary = storyCreation.getSummary();
        }

        return StorySummaryResponseDto.builder()
                .storyId(storyCreation.getId())
                .status(storyCreation.getStatus())
                .summary(summary)
                .build();
    }

    @Transactional(readOnly = true)
    public StoryCharactersResponseDto getCharacters(String storyId) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        List<CharacterDto> characters = null;

        if (storyCreation.getAnalysisResultFileKey() != null && !storyCreation.getAnalysisResultFileKey().isBlank()) {
            try {
                String analysisJson = s3Service.downloadFileContent(storyCreation.getAnalysisResultFileKey());
                NovelAnalysisResponseDto analysisData = objectMapper.readValue(analysisJson, NovelAnalysisResponseDto.class);
                characters = analysisData.getCharacters();
            } catch (Exception e) {
                log.error("Failed to download analysis result from S3: {}", storyCreation.getAnalysisResultFileKey(), e);
            }
        }
        else if (storyCreation.getCharactersJson() != null) {
            try {
                characters = objectMapper.readValue(
                        storyCreation.getCharactersJson(),
                        new TypeReference<List<CharacterDto>>() {}
                );
            } catch (Exception e) {
                log.error("Failed to parse characters JSON", e);
            }
        }

        return StoryCharactersResponseDto.builder()
                .storyId(storyCreation.getId())
                .status(storyCreation.getStatus())
                .characters(characters)
                .build();
    }

    @Transactional(readOnly = true)
    public StoryGaugesResponseDto getGauges(String storyId) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        List<GaugeDto> gauges = null;

        if (storyCreation.getAnalysisResultFileKey() != null && !storyCreation.getAnalysisResultFileKey().isBlank()) {
            try {
                String analysisJson = s3Service.downloadFileContent(storyCreation.getAnalysisResultFileKey());
                NovelAnalysisResponseDto analysisData = objectMapper.readValue(analysisJson, NovelAnalysisResponseDto.class);
                gauges = analysisData.getGauges();
            } catch (Exception e) {
                log.error("Failed to download analysis result from S3: {}", storyCreation.getAnalysisResultFileKey(), e);
            }
        }
        else if (storyCreation.getGaugesJson() != null) {
            try {
                gauges = objectMapper.readValue(
                        storyCreation.getGaugesJson(),
                        new TypeReference<List<GaugeDto>>() {}
                );
            } catch (Exception e) {
                log.error("Failed to parse gauges JSON", e);
            }
        }

        return StoryGaugesResponseDto.builder()
                .storyId(storyCreation.getId())
                .status(storyCreation.getStatus())
                .gauges(gauges)
                .build();
    }

    @Transactional
    public GaugeSelectionResponseDto selectGauges(String storyId, GaugeSelectionRequestDto request) {
        log.info("=== Select Gauges ===");
        log.info("StoryId: {}, Selected: {}", storyId, request.getSelectedGaugeIds());

        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        if (storyCreation.getStatus() != StoryCreation.CreationStatus.GAUGES_READY) {
            throw new IllegalStateException("Cannot select gauges: current status is " + storyCreation.getStatus());
        }

        try {
            storyCreation.setSelectedGaugeIdsJson(
                    objectMapper.writeValueAsString(request.getSelectedGaugeIds())
            );
            storyCreation.setStatus(StoryCreation.CreationStatus.GAUGES_SELECTED);
            storyCreation.setCurrentPhase("GAUGES_SELECTED");
            storyCreation.setProgressPercentage(40);
            storyCreation.setProgressMessage("Gauges selected");

            storyCreation = storyCreationRepository.save(storyCreation);

            List<GaugeDto> allGauges = null;

            if (storyCreation.getAnalysisResultFileKey() != null && !storyCreation.getAnalysisResultFileKey().isBlank()) {
                String analysisJson = s3Service.downloadFileContent(storyCreation.getAnalysisResultFileKey());
                NovelAnalysisResponseDto analysisData = objectMapper.readValue(analysisJson, NovelAnalysisResponseDto.class);
                allGauges = analysisData.getGauges();
            }
            else if (storyCreation.getGaugesJson() != null) {
                allGauges = objectMapper.readValue(
                        storyCreation.getGaugesJson(),
                        new TypeReference<List<GaugeDto>>() {}
                );
            }

            if (allGauges == null) {
                throw new com.story.game.common.exception.InvalidStateException("No gauges found");
            }

            List<GaugeDto> selectedGauges = allGauges.stream()
                    .filter(g -> request.getSelectedGaugeIds().contains(g.getId()))
                    .toList();

            // ‚úÖ Now call /finalize-analysis to generate final endings based on selected gauges
            try {
                log.info("Calling /ai/finalize-analysis with {} selected gauges", selectedGauges.size());

                Map<String, Object> finalizeRequest = Map.of(
                        "novel_summary", storyCreation.getSummary(),
                        "selected_gauges", selectedGauges
                );

                @SuppressWarnings("unchecked")
                Map<String, Object> finalizeResponse = relayServerWebClient.post()
                        .uri("/ai/finalize-analysis")
                        .bodyValue(finalizeRequest)
                        .retrieve()
                        .bodyToMono(Map.class)
                        .block();

                if (finalizeResponse != null && finalizeResponse.containsKey("finalEndings")) {
                    storyCreation.setEndingConfigJson(
                            objectMapper.writeValueAsString(finalizeResponse.get("finalEndings"))
                    );
                    storyCreationRepository.save(storyCreation);
                    log.info("Final endings generated and saved successfully");
                } else {
                    log.warn("No finalEndings in finalize-analysis response");
                }
            } catch (Exception e) {
                log.error("Failed to finalize analysis (generate final endings)", e);
                // Don't fail the whole request - just log the error
                // The system can still proceed without finalEndings
            }

            return GaugeSelectionResponseDto.builder()
                    .storyId(storyCreation.getId())
                    .status(storyCreation.getStatus())
                    .selectedGauges(selectedGauges)
                    .build();

        } catch (Exception e) {
            log.error("Failed to select gauges", e);
            throw new com.story.game.common.exception.InvalidStateException("Failed to select gauges: " + e.getMessage());
        }
    }

    @Transactional
    public void selectAndIndexCharacters(String storyId, SelectCharactersRequestDto request) {
        log.info("=== Select and Index Characters ===");
        log.info("StoryId: {}, Selected characters: {}", storyId, request.getCharacterNames());

        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        // Validate story state - only allow character selection at appropriate stages
        StoryCreation.CreationStatus status = storyCreation.getStatus();
        if (status != StoryCreation.CreationStatus.CHARACTERS_READY &&
            status != StoryCreation.CreationStatus.GAUGES_READY &&
            status != StoryCreation.CreationStatus.GAUGES_SELECTED &&
            status != StoryCreation.CreationStatus.CONFIGURED) {
            throw new IllegalStateException(
                "Cannot select characters at current stage: " + status +
                ". Characters can only be selected after character analysis is complete and before story generation starts."
            );
        }

        // Validate story state
        if (storyCreation.getCharactersJson() == null || storyCreation.getCharactersJson().isBlank()) {
            throw new com.story.game.common.exception.InvalidStateException("No characters available for this story");
        }

        // Log if characters were already selected (overwriting)
        if (storyCreation.getSelectedCharactersForChatJson() != null &&
            !storyCreation.getSelectedCharactersForChatJson().isBlank()) {
            log.warn("Overwriting previously selected characters for story: {}", storyId);
        }

        try {
            // Parse existing characters
            List<CharacterDto> allCharacters = objectMapper.readValue(
                    storyCreation.getCharactersJson(),
                    new TypeReference<List<CharacterDto>>() {}
            );

            // Validate selected character names exist
            List<String> availableNames = allCharacters.stream()
                    .map(CharacterDto::getName)
                    .collect(Collectors.toList());

            for (String selectedName : request.getCharacterNames()) {
                if (!availableNames.contains(selectedName)) {
                    throw new IllegalArgumentException("Character not found: " + selectedName);
                }
            }

            // Save selected characters to StoryCreation
            storyCreation.setSelectedCharactersForChatJson(
                    objectMapper.writeValueAsString(request.getCharacterNames())
            );
            storyCreationRepository.save(storyCreation);

            // Index selected characters to NPC AI
            indexSelectedCharacters(storyCreation, allCharacters, request.getCharacterNames());

            log.info("Characters selected and indexed successfully");

        } catch (Exception e) {
            log.error("Failed to select and index characters", e);
            throw new com.story.game.common.exception.ExternalServiceException("Failed to select characters: " + e.getMessage());
        }
    }

    private void indexSelectedCharacters(StoryCreation storyCreation,
                                        List<CharacterDto> allCharacters,
                                        List<String> selectedNames) {
        try {
            // Filter only selected characters
            List<CharacterDto> selectedCharacters = allCharacters.stream()
                    .filter(c -> selectedNames.contains(c.getName()))
                    .collect(Collectors.toList());

            // ========== STEP 1: ÏÜåÏÑ§ ÌïôÏäµ (RAG ÏãúÏä§ÌÖúÏóê ÏÜåÏÑ§ ÏõêÎ≥∏ Ïù∏Îç±Ïã±) ==========
            if (storyCreation.getS3FileKey() != null && !storyCreation.getS3FileKey().isBlank()) {
                log.info("=== Indexing Novel to RAG System ===");
                log.info("Story: {} ({})", storyCreation.getTitle(), storyCreation.getId());
                log.info("S3 File Key: {}", storyCreation.getS3FileKey());

                try {
                    NovelIndexRequestDto novelIndexRequest = NovelIndexRequestDto.builder()
                            .storyId(storyCreation.getId())
                            .title(storyCreation.getTitle())
                            .fileKey(storyCreation.getS3FileKey())
                            .bucket(bucketName)
                            .build();

                    Boolean novelIndexResult = ragService.indexNovel(novelIndexRequest);

                    if (novelIndexResult) {
                        log.info("‚úÖ Novel indexed successfully for story: {}", storyCreation.getId());
                    } else {
                        log.warn("‚ö†Ô∏è Novel indexing failed for story: {}", storyCreation.getId());
                    }
                } catch (Exception e) {
                    log.warn("Failed to index novel (non-critical): {}", e.getMessage(), e);
                }
            } else {
                log.warn("‚ö†Ô∏è No S3 file key found for story: {}. Skipping novel indexing.", storyCreation.getId());
            }

            // ========== STEP 2: Ï∫êÎ¶≠ÌÑ∞ Ï†ïÎ≥¥ ÏÑ§Ï†ï ==========
            // Build story context (Í≥µÌÜµ Ï†ïÎ≥¥)
            StringBuilder storyContext = new StringBuilder();
            storyContext.append("=== ÏÜåÏÑ§ Ï†ïÎ≥¥ ===").append(System.lineSeparator());
            storyContext.append("Ï†úÎ™©: ").append(storyCreation.getTitle()).append(System.lineSeparator());
            if (storyCreation.getGenre() != null) {
                storyContext.append("Ïû•Î•¥: ").append(storyCreation.getGenre()).append(System.lineSeparator());
            }
            storyContext.append(System.lineSeparator());

            // Add story summary
            if (storyCreation.getSummary() != null && !storyCreation.getSummary().isBlank()) {
                storyContext.append("=== Ï§ÑÍ±∞Î¶¨ ÏöîÏïΩ ===").append(System.lineSeparator());
                storyContext.append(storyCreation.getSummary()).append(System.lineSeparator());
                storyContext.append(System.lineSeparator());
            }

            // Îã§Î•∏ Ï∫êÎ¶≠ÌÑ∞ Ï†ïÎ≥¥ Ï∂îÍ∞Ä (Í¥ÄÍ≥Ñ ÌååÏïÖÏö©)
            storyContext.append("=== Ï£ºÏöî Îì±Ïû•Ïù∏Î¨º ===").append(System.lineSeparator());
            for (CharacterDto character : selectedCharacters) {
                if (character.getName() != null) {
                    storyContext.append("- ").append(character.getName());
                    if (character.getDescription() != null && !character.getDescription().isBlank()) {
                        storyContext.append(": ").append(character.getDescription());
                    }
                    storyContext.append(System.lineSeparator());
                }
            }
            storyContext.append(System.lineSeparator());

            // Í∞Å Ï∫êÎ¶≠ÌÑ∞ÎßàÎã§ Í∞úÎ≥ÑÏ†ÅÏúºÎ°ú ÏÑ§Ï†ï
            int successCount = 0;
            int failCount = 0;

            for (CharacterDto character : selectedCharacters) {
                if (character.getName() == null || character.getName().isBlank()) {
                    continue;
                }

                try {
                    // Generate unique character ID: {storyId}_{characterName}
                    String characterId = storyCreation.getId() + "_" + character.getName();

                    // Build character-specific description
                    StringBuilder characterDescription = new StringBuilder();

                    // Add story context
                    characterDescription.append(storyContext);

                    // Add specific character information
                    characterDescription.append("=== Ïù¥ Ï∫êÎ¶≠ÌÑ∞Ïùò ÏÉÅÏÑ∏ Ï†ïÎ≥¥ ===").append(System.lineSeparator());
                    characterDescription.append("Ïù¥Î¶Ñ: ").append(character.getName()).append(System.lineSeparator());

                    // Aliases
                    if (character.getAliases() != null && !character.getAliases().isEmpty()) {
                        characterDescription.append("Î≥ÑÏπ≠: ").append(String.join(", ", character.getAliases()))
                                .append(System.lineSeparator());
                    }

                    // Description
                    if (character.getDescription() != null && !character.getDescription().isBlank()) {
                        characterDescription.append("ÏÑ±Í≤© Î∞è ÌäπÏßï: ").append(character.getDescription())
                                .append(System.lineSeparator());
                    }

                    // Relationships
                    if (character.getRelationships() != null && !character.getRelationships().isEmpty()) {
                        characterDescription.append("Í¥ÄÍ≥Ñ:").append(System.lineSeparator());
                        for (String relationship : character.getRelationships()) {
                            characterDescription.append("  - ").append(relationship).append(System.lineSeparator());
                        }
                    }

                    // Call RagService to set character information (not indexing)
                    com.story.game.rag.dto.CharacterSetRequestDto setRequest =
                        com.story.game.rag.dto.CharacterSetRequestDto.builder()
                            .characterId(characterId)
                            .characterName(character.getName())
                            .characterDescription(characterDescription.toString())
                            .build();

                    Boolean result = ragService.setCharacter(setRequest);

                    if (result) {
                        successCount++;
                        log.info("‚úÖ Character '{}' set successfully with ID: {}", character.getName(), characterId);
                    } else {
                        failCount++;
                        log.warn("‚ö†Ô∏è Character '{}' setting failed with ID: {}", character.getName(), characterId);
                    }

                } catch (Exception e) {
                    failCount++;
                    log.warn("Failed to set character '{}': {}", character.getName(), e.getMessage());
                }
            }

            log.info("Character setting completed - Success: {}, Failed: {}", successCount, failCount);

        } catch (Exception e) {
            // Ïù∏Îç±Ïã± Ïã§Ìå®Îäî ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏúºÎØÄÎ°ú Í≤ΩÍ≥†Îßå Î°úÍ∑∏
            log.warn("Failed to index selected characters (non-critical): {}. Story creation will continue.", e.getMessage());
        }
    }

    @Transactional(readOnly = true)
    public SelectedCharactersResponseDto getSelectedCharacters(String storyId) {
        log.info("=== Get Selected Characters ===");
        log.info("StoryId: {}", storyId);

        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        // Check if characters have been selected
        if (storyCreation.getSelectedCharactersForChatJson() == null ||
            storyCreation.getSelectedCharactersForChatJson().isBlank()) {
            return SelectedCharactersResponseDto.builder()
                    .storyId(storyCreation.getId())
                    .storyDataId(storyCreation.getStoryDataId())
                    .chatCharacterId(storyCreation.getId())  // NPC ÎåÄÌôîÏö© - storyIdÏôÄ ÎèôÏùº
                    .hasSelection(false)
                    .selectedCharacterNames(List.of())
                    .selectedCharacters(List.of())
                    .build();
        }

        try {
            // Parse selected character names
            List<String> selectedNames = objectMapper.readValue(
                    storyCreation.getSelectedCharactersForChatJson(),
                    new TypeReference<List<String>>() {}
            );

            // Parse all characters
            List<CharacterDto> allCharacters = new ArrayList<>();
            if (storyCreation.getCharactersJson() != null && !storyCreation.getCharactersJson().isBlank()) {
                allCharacters = objectMapper.readValue(
                        storyCreation.getCharactersJson(),
                        new TypeReference<List<CharacterDto>>() {}
                );
            }

            // Filter selected characters and assign chatCharacterId to each
            List<CharacterDto> selectedCharacters = allCharacters.stream()
                    .filter(c -> selectedNames.contains(c.getName()))
                    .map(c -> {
                        // Generate unique chatCharacterId for each character
                        String chatCharId = storyCreation.getId() + "_" + c.getName();
                        return CharacterDto.builder()
                                .name(c.getName())
                                .aliases(c.getAliases())
                                .description(c.getDescription())
                                .relationships(c.getRelationships())
                                .chatCharacterId(chatCharId)  // Assign unique ID
                                .build();
                    })
                    .collect(Collectors.toList());

            return SelectedCharactersResponseDto.builder()
                    .storyId(storyCreation.getId())
                    .storyDataId(storyCreation.getStoryDataId())
                    .chatCharacterId(null)  // Deprecated - Ïù¥Ï†ú Í∞Å Ï∫êÎ¶≠ÌÑ∞Í∞Ä Í≥†Ïú† IDÎ•º Í∞ÄÏßê
                    .hasSelection(true)
                    .selectedCharacterNames(selectedNames)
                    .selectedCharacters(selectedCharacters)
                    .build();

        } catch (Exception e) {
            log.error("Failed to parse selected characters", e);
            throw new com.story.game.common.exception.InvalidStateException("Failed to retrieve selected characters: " + e.getMessage());
        }
    }

    /**
     * ÏÜåÏÑ§ Í∏∏Ïù¥Ïóê Îî∞Îùº ÏµúÏ†ÅÏùò ÏóêÌîºÏÜåÎìú ÏàòÎ•º Í≥ÑÏÇ∞
     *
     * Í∏∞Ï§Ä:
     * - ~5ÎßåÏûê: 3Í∞ú (Îß§Ïö∞ ÏßßÏùÄ ÏÜåÏÑ§)
     * - 5~8ÎßåÏûê: 4Í∞ú
     * - 8~15ÎßåÏûê: 5Í∞ú (Î°úÎØ∏Ïò§ÏôÄ Ï§ÑÎ¶¨Ïó£ ÏàòÏ§Ä)
     * - 15~30ÎßåÏûê: 6Í∞ú
     * - 30~50ÎßåÏûê: 7Í∞ú
     * - 50~80ÎßåÏûê: 8Í∞ú
     * - 80~100ÎßåÏûê: 9Í∞ú
     * - 100ÎßåÏûê Ïù¥ÏÉÅ: 10Í∞ú (Î™®ÎπÑÎîï ÏàòÏ§Ä)
     *
     * @param storyCreation Ïä§ÌÜ†Î¶¨ ÏÉùÏÑ± Ï†ïÎ≥¥
     * @return ÏµúÏ†Å ÏóêÌîºÏÜåÎìú Ïàò (3~10)
     */
    private int calculateOptimalEpisodes(StoryCreation storyCreation) {
        if (storyCreation.getNovelText() == null || storyCreation.getNovelText().isEmpty()) {
            log.warn("Novel text is empty, using default episode count: 5");
            return 5;
        }

        int charCount = storyCreation.getNovelText().length();
        int episodes;

        if (charCount < 50000) {
            episodes = 3;
        } else if (charCount < 80000) {
            episodes = 4;
        } else if (charCount < 150000) {
            episodes = 5;
        } else if (charCount < 300000) {
            episodes = 6;
        } else if (charCount < 500000) {
            episodes = 7;
        } else if (charCount < 800000) {
            episodes = 8;
        } else if (charCount < 1000000) {
            episodes = 9;
        } else {
            episodes = 10;
        }

        log.info("Auto-calculated episodes for {} characters: {} episodes", charCount, episodes);
        return episodes;
    }

    @Transactional
    public StoryConfigResponseDto configureStory(String storyId, StoryConfigRequestDto request) {
        log.info("=== Configure Story ===");
        log.info("StoryId: {}", storyId);

        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        // Allow configuration at GAUGES_SELECTED or CONFIGURED (for re-configuration)
        if (storyCreation.getStatus() != StoryCreation.CreationStatus.GAUGES_SELECTED &&
            storyCreation.getStatus() != StoryCreation.CreationStatus.CONFIGURED) {
            throw new IllegalStateException("Cannot configure: current status is " + storyCreation.getStatus() +
                    ". Configuration is only allowed at GAUGES_SELECTED or CONFIGURED stage.");
        }

        // Log if this is a re-configuration
        if (storyCreation.getStatus() == StoryCreation.CreationStatus.CONFIGURED) {
            log.info("Re-configuring story. Previous episodes: {}, Previous maxDepth: {}",
                    storyCreation.getNumEpisodes(), storyCreation.getMaxDepth());
        }

        try {
            // ÏÜåÏÑ§ Í∏∏Ïù¥ Í∏∞Î∞ò ÏóêÌîºÏÜåÎìú Ïàò ÏûêÎèô Í≥ÑÏÇ∞
            int novelLength = (storyCreation.getNovelText() != null) ? storyCreation.getNovelText().length() : 0;
            int calculatedEpisodes = calculateOptimalEpisodes(storyCreation);
            int finalEpisodes = (request.getNumEpisodes() != null) ? request.getNumEpisodes() : calculatedEpisodes;

            log.info("Novel length: {} chars, Calculated episodes: {}, Final episodes: {}, User override: {}",
                    novelLength,
                    calculatedEpisodes,
                    finalEpisodes,
                    request.getNumEpisodes() != null);

            storyCreation.setDescription(request.getDescription());
            storyCreation.setNumEpisodes(finalEpisodes);
            storyCreation.setMaxDepth(request.getMaxDepth());
            storyCreation.setNumEpisodeEndings(request.getNumEpisodeEndings());

            // Save endingConfig as JSON
            if (request.getEndingConfig() != null) {
                storyCreation.setEndingConfigJson(objectMapper.writeValueAsString(request.getEndingConfig()));
                log.info("Ending config saved: {}", request.getEndingConfig());
            }

            storyCreation.setStatus(StoryCreation.CreationStatus.CONFIGURED);
            storyCreation.setCurrentPhase("CONFIGURED");
            storyCreation.setProgressPercentage(50);
            storyCreation.setProgressMessage("Story configured");

            storyCreation.setCompletedEpisodes(0);
            storyCreation.setTotalEpisodesToGenerate(finalEpisodes);  // ÏûêÎèô Í≥ÑÏÇ∞Îêú Í∞í ÏÇ¨Ïö©

            storyCreation = storyCreationRepository.save(storyCreation);

            return StoryConfigResponseDto.builder()
                    .storyId(storyCreation.getId())
                    .status(storyCreation.getStatus())
                    .config(StoryConfigResponseDto.ConfigData.builder()
                            .description(request.getDescription())
                            .numEpisodes(finalEpisodes)  // ÏûêÎèô Í≥ÑÏÇ∞Îêú Í∞í ÏÇ¨Ïö©
                            .maxDepth(request.getMaxDepth())
                            .numEpisodeEndings(request.getNumEpisodeEndings())
                            .build())
                    .build();

        } catch (Exception e) {
            log.error("Failed to configure story", e);
            throw new com.story.game.common.exception.InvalidStateException("Failed to configure story: " + e.getMessage());
        }
    }

    @Transactional(readOnly = true)
    public StoryProgressResponseDto getProgress(String storyId) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        return StoryProgressResponseDto.builder()
                .storyId(storyCreation.getId())
                .status(storyCreation.getStatus())
                .progress(StoryProgressResponseDto.ProgressData.builder()
                        .currentPhase(storyCreation.getCurrentPhase())
                        .completedEpisodes(storyCreation.getCompletedEpisodes())
                        .totalEpisodes(storyCreation.getTotalEpisodesToGenerate())
                        .percentage(storyCreation.getProgressPercentage())
                        .message(storyCreation.getProgressMessage())
                        .error(storyCreation.getErrorMessage())
                        .build())
                .build();
    }

    @Transactional(readOnly = true)
    public StoryResultResponseDto getResult(String storyId) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        if (storyCreation.getStatus() != StoryCreation.CreationStatus.COMPLETED) {
            throw new IllegalStateException("Story generation is not completed yet");
        }

        StoryData storyData = storyDataRepository.findById(storyCreation.getStoryDataId())
                .orElseThrow(() -> new RuntimeException("Story data not found"));

        try {
            String storyJson = s3Service.downloadFileContent(storyData.getStoryFileKey());

            FullStoryDto fullStory = objectMapper.readValue(storyJson, FullStoryDto.class);
            EpisodeDto firstEpisode = fullStory.getEpisodes().stream()
                    .filter(ep -> ep.getOrder() == 1)
                    .findFirst()
                    .orElse(null);

            return StoryResultResponseDto.builder()
                    .storyId(storyCreation.getId())
                    .status(storyCreation.getStatus())
                    .storyDataId(storyData.getId())
                    .metadata(StoryResultResponseDto.MetadataData.builder()
                            .title(storyData.getTitle())
                            .genre(storyData.getGenre())
                            .description(storyData.getDescription())
                            .totalEpisodes(storyData.getTotalEpisodes())
                            .totalNodes(storyData.getTotalNodes())
                            .totalGauges(2)
                            .createdAt(storyData.getCreatedAt())
                            .build())
                    .preview(StoryResultResponseDto.PreviewData.builder()
                            .firstEpisodeTitle(firstEpisode != null ? firstEpisode.getTitle() : null)
                            .firstEpisodeIntro(firstEpisode != null ? firstEpisode.getIntroText() : null)
                            .selectedGauges(null)
                            .build())
                    .build();

        } catch (Exception e) {
            log.error("Failed to parse story result", e);
            throw new com.story.game.common.exception.InvalidStateException("Failed to parse story result: " + e.getMessage());
        }
    }

    @Transactional
    public void updateStoryStatus(String storyId, StoryCreation.CreationStatus status, String errorMessage) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found"));

        storyCreation.setStatus(status);
        storyCreation.setErrorMessage(errorMessage);

        if (status == StoryCreation.CreationStatus.FAILED) {
            storyCreation.setCurrentPhase("FAILED");
            storyCreation.setProgressMessage("Failed: " + errorMessage);
        }

        storyCreationRepository.save(storyCreation);
    }

    @Transactional(readOnly = true)
    public FullStoryDto getFullStoryData(String storyId) {
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new EntityNotFoundException("Story not found: " + storyId));

        if (storyCreation.getStatus() != StoryCreation.CreationStatus.COMPLETED) {
            throw new IllegalStateException("Story generation is not completed yet");
        }

        StoryData storyData = storyDataRepository.findById(storyCreation.getStoryDataId())
                .orElseThrow(() -> new RuntimeException("Story data not found"));

        try {
            String storyJson = s3Service.downloadFileContent(storyData.getStoryFileKey());
            return objectMapper.readValue(storyJson, FullStoryDto.class);
        } catch (Exception e) {
            log.error("Failed to parse story JSON", e);
            throw new com.story.game.common.exception.InvalidStateException("Failed to parse story data: " + e.getMessage());
        }
    }

    @Transactional
    public StoryUploadResponseDto uploadNovelFromS3(S3UploadRequestDto request, com.story.game.auth.entity.User user) {
        log.info("=== Upload Novel From S3 ===");
        log.info("Title: {}, FileKey: {}, User: {}", request.getTitle(), request.getFileKey(), user != null ? user.getUsername() : "null");

        String storyId = "story_" + UUID.randomUUID().toString().substring(0, 8);

        StoryCreation storyCreation = StoryCreation.builder()
                .id(storyId)
                .user(user)
                .title(request.getTitle())
                .genre(request.getGenre())
                .novelText("")
                .s3FileKey(request.getFileKey())
                .status(StoryCreation.CreationStatus.ANALYZING)
                .currentPhase("ANALYZING")
                .progressPercentage(0)
                .progressMessage("Starting novel analysis from S3...")
                .build();

        storyCreation = storyCreationRepository.save(storyCreation);

        startAnalysisFromS3Async(storyId, request.getFileKey());

        return StoryUploadResponseDto.builder()
                .storyId(storyCreation.getId())
                .title(storyCreation.getTitle())
                .genre(storyCreation.getGenre())
                .status(storyCreation.getStatus())
                .createdAt(storyCreation.getCreatedAt())
                .build();
    }

    @Transactional
    public void startAnalysisFromS3Async(String storyId, String fileKey) {
        try {
            log.info("Starting AI analysis from S3 for story: {}, bucket: {}, fileKey: {}", storyId, bucketName, fileKey);

            // Generate pre-signed URL for AI server to upload analysis result
            String resultFileKey = "analysis/" + UUID.randomUUID().toString() + ".json";
            String s3UploadUrl = s3Service.generatePresignedUploadUrl(resultFileKey).getUrl();
            log.info("Generated Pre-signed URL for AI server to upload analysis result: {}", resultFileKey);

            // Generate pre-signed download URL for RAG server to access original novel
            String novelDownloadUrl = s3Service.generatePresignedDownloadUrl(fileKey);
            log.info("Generated Pre-signed download URL for RAG server to access original novel: {}", fileKey);

            // Index novel to RAG server (Î≥ëÎ†¨ Ï≤òÎ¶¨ - Ïã§Ìå®Ìï¥ÎèÑ Î∂ÑÏÑù Í≥ÑÏÜç ÏßÑÌñâ)
            StoryCreation storyCreationForRag = storyCreationRepository.findById(storyId)
                    .orElseThrow(() -> new RuntimeException("Story not found"));
            NovelIndexRequestDto ragRequest = NovelIndexRequestDto.builder()
                    .storyId(storyId)
                    .title(storyCreationForRag.getTitle())
                    .fileKey(fileKey)
                    .bucket(bucketName)
                    .build();
            ragService.indexNovel(ragRequest);

            NovelAnalysisRequestDto aiRequest = NovelAnalysisRequestDto.builder()
                    .fileKey(fileKey)
                    .bucket(bucketName)
                    .s3UploadUrl(s3UploadUrl)
                    .resultFileKey(resultFileKey)
                    .novelDownloadUrl(novelDownloadUrl)  // RAGÍ∞Ä ÏõêÎ≥∏ ÏÜåÏÑ§ÏùÑ Îã§Ïö¥Î°úÎìúÌï† URL
                    .build();

            log.info("Calling relay-server /ai/analyze-from-s3 endpoint for S3 mode");

            NovelAnalysisResponseDto response = relayServerWebClient.post()
                    .uri("/ai/analyze-from-s3")  // S3 Ï†ÑÏö© ÏóîÎìúÌè¨Ïù∏Ìä∏ ÏÇ¨Ïö©
                    .bodyValue(aiRequest)
                    .retrieve()
                    .bodyToMono(NovelAnalysisResponseDto.class)
                    .block();

            if (response == null) {
                throw new com.story.game.common.exception.ExternalServiceException("No response from AI server");
            }

            StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                    .orElseThrow(() -> new RuntimeException("Story not found"));

            // [ÏàòÏ†ï] S3 Î™®ÎìúÏùº ÎïåÎèÑ Îç∞Ïù¥ÌÑ∞Î•º Îã§Ïö¥Î°úÎìúÌïòÏó¨ DBÏóê Ï†ÄÏû• (ÎàÑÎùΩ Î∞©ÏßÄ)
            if (response.isS3Mode()) {
                log.info("AI server uploaded analysis result to S3 directly: {}", response.getFileKey());
                storyCreation.setAnalysisResultFileKey(response.getFileKey());

                // --- ÌïÑÏàò Îç∞Ïù¥ÌÑ∞ DB Ï†ÄÏû• ---
                try {
                    String analysisJson = s3Service.downloadFileContent(response.getFileKey());
                    NovelAnalysisResponseDto analysisData = objectMapper.readValue(analysisJson, NovelAnalysisResponseDto.class);

                    storyCreation.setSummary(analysisData.getSummary());
                    storyCreation.setCharactersJson(objectMapper.writeValueAsString(analysisData.getCharacters()));
                    storyCreation.setGaugesJson(objectMapper.writeValueAsString(analysisData.getGauges()));
                    // Note: finalEndings will be generated after user selects gauges (in selectGauges method)

                    log.info("Synced analysis data from S3 to DB for story: {}", storyId);
                } catch (Exception e) {
                    log.error("Failed to sync analysis data from S3 to DB", e);
                    throw new com.story.game.common.exception.InvalidStateException("Failed to sync analysis data: " + e.getMessage());
                }
            }
            else {
                storyCreation.setSummary(response.getSummary());
                storyCreation.setCharactersJson(objectMapper.writeValueAsString(response.getCharacters()));
                storyCreation.setGaugesJson(objectMapper.writeValueAsString(response.getGauges()));
                // Note: finalEndings will be generated after user selects gauges (in selectGauges method)
            }

            storyCreation.setStatus(StoryCreation.CreationStatus.GAUGES_READY);
            storyCreation.setCurrentPhase("GAUGES_READY");
            storyCreation.setProgressPercentage(30);
            storyCreation.setProgressMessage("Analysis completed. Ready for gauge selection.");

            storyCreationRepository.save(storyCreation);

            log.info("AI analysis from S3 completed for story: {}", storyId);

            // Learn novel style for image generation and generate thumbnail (non-blocking, failure is non-critical)
            try {
                // Generate presigned URL for thumbnail upload
                String thumbnailFileKey = "thumbnails/" + storyId + "/thumbnail.png";
                String thumbnailS3Url = s3Service.generatePresignedUploadUrl(thumbnailFileKey).getUrl();
                log.info("Generated presigned URL for thumbnail upload: {}", thumbnailFileKey);

                // Build request with S3 info (AI-IMAGE will download from S3)
                NovelStyleLearnRequestDto styleRequest = NovelStyleLearnRequestDto.builder()
                        .story_id(storyId)
                        .title(storyCreation.getTitle())
                        .novel_s3_bucket(bucketName)
                        .novel_s3_key(fileKey)
                        .thumbnail_s3_url(thumbnailS3Url)
                        .thumbnail_s3_bucket(bucketName)
                        .thumbnail_s3_key(thumbnailFileKey)
                        .build();

                log.info("üìã Thumbnail request details (S3 mode):");
                log.info("   novel_s3_bucket: {}", bucketName);
                log.info("   novel_s3_key: {}", fileKey);
                log.info("   thumbnail_s3_url: {}", thumbnailS3Url != null ? "SET (length: " + thumbnailS3Url.length() + ")" : "NULL");
                log.info("   thumbnail_s3_bucket: {}", bucketName);
                log.info("   thumbnail_s3_key: {}", thumbnailFileKey);

                com.story.game.ai.dto.NovelStyleLearnResponseDto styleResult = relayServerClient.learnNovelStyle(styleRequest);
                if (styleResult != null && styleResult.getThumbnail_image_url() != null) {
                    log.info("‚úÖ Novel style learned successfully with thumbnail for story: {}", storyId);

                    // Save thumbnail file key to DB
                    storyCreation.setThumbnailFileKey(thumbnailFileKey);
                    storyCreationRepository.save(storyCreation);
                    log.info("‚úÖ Saved thumbnail fileKey to DB: {}", thumbnailFileKey);
                } else {
                    log.warn("Novel style learning succeeded but no thumbnail generated for story: {} (non-critical)", storyId);
                }
            } catch (Exception e) {
                log.warn("Failed to learn novel style or generate thumbnail (non-critical): {}", e.getMessage());
            }

        } catch (Exception e) {
            log.error("Failed to analyze novel from S3", e);

            StoryCreation storyCreation = storyCreationRepository.findById(storyId).orElse(null);
            if (storyCreation != null) {
                storyCreation.setStatus(StoryCreation.CreationStatus.FAILED);
                storyCreation.setCurrentPhase("FAILED");
                storyCreation.setProgressMessage("Analysis failed: " + e.getMessage());
                storyCreationRepository.save(storyCreation);
            }
        }
    }

    /**
     * Ïä§ÌÜ†Î¶¨ ÏÇ≠Ï†ú (ÏÉùÏÑ± Ï§ëÏù¥Í±∞ÎÇò ÏôÑÎ£åÎêú Ïä§ÌÜ†Î¶¨)
     * - StoryCreation, StoryData, Episodes, Nodes, Choices Î™®Îëê ÏÇ≠Ï†ú
     * - S3Ïóê Ï†ÄÏû•Îêú ÌååÏùºÎì§ÎèÑ ÏÇ≠Ï†ú (ÏÜåÏÑ§ ÏõêÎ≥∏, Î∂ÑÏÑù Í≤∞Í≥º, Ïä§ÌÜ†Î¶¨ JSON, Ïù¥ÎØ∏ÏßÄ Îì±)
     */
    @Transactional
    public void deleteStory(String storyId, com.story.game.auth.entity.User user) {
        log.info("=== Delete Story ===");
        log.info("StoryId: {}, User: {}", storyId, user.getUsername());

        // 1. Find story creation
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new com.story.game.common.exception.ResourceNotFoundException("Story not found: " + storyId));

        // 2. Authorization check - Î≥∏Ïù∏Ïù¥ ÏÉùÏÑ±Ìïú Ïä§ÌÜ†Î¶¨Îßå ÏÇ≠Ï†ú Í∞ÄÎä•
        if (storyCreation.getUser() == null) {
            throw new com.story.game.common.exception.UnauthorizedException("Unauthorized: Story has no owner");
        }

        if (!storyCreation.getUser().getId().equals(user.getId())) {
            throw new com.story.game.common.exception.UnauthorizedException("Unauthorized: You can only delete your own stories");
        }

        // 3. S3 ÌååÏùº ÏÇ≠Ï†ú (Ïã§Ìå®Ìï¥ÎèÑ Í≥ÑÏÜç ÏßÑÌñâ)
        deleteS3FilesForStory(storyCreation);

        // 3-1. RAG ÏÑúÎ≤Ñ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú (Ïã§Ìå®Ìï¥ÎèÑ Í≥ÑÏÜç ÏßÑÌñâ)
        try {
            ragService.deleteStoryFromRag(storyId);
            log.info("RAG data deletion requested for story: {}", storyId);
        } catch (Exception e) {
            log.warn("Failed to delete RAG data (non-critical), continuing with deletion: {}", storyId, e);
        }

        // 3-2. Chat Conversations ÏÇ≠Ï†ú (DBÏóê Ï†ÄÏû•Îêú ÎåÄÌôî ÎÇ¥Ïó≠)
        try {
            ragService.deleteConversationsByStoryId(user.getUsername(), storyId);
            log.info("Chat conversations deleted for story: {}", storyId);
        } catch (Exception e) {
            log.warn("Failed to delete chat conversations (non-critical): {}", storyId, e);
        }

        // 4. StoryData ÏÇ≠Ï†ú (ÏôÑÎ£åÎêú Ïä§ÌÜ†Î¶¨Ïùò Í≤ΩÏö∞)
        if (storyCreation.getStoryDataId() != null) {
            storyDataRepository.findById(storyCreation.getStoryDataId()).ifPresent(storyData -> {
                log.info("Deleting StoryData: {}", storyData.getId());

                // StoryDataÏùò S3 ÌååÏùºÎèÑ ÏÇ≠Ï†ú
                if (storyData.getStoryFileKey() != null) {
                    deleteS3File(storyData.getStoryFileKey(), "Story JSON");
                }
                if (storyData.getThumbnailFileKey() != null) {
                    deleteS3File(storyData.getThumbnailFileKey(), "Thumbnail");
                }

                storyDataRepository.delete(storyData);
            });
        }

        // 5. StoryCreation ÏÇ≠Ï†ú (Ïó∞Í¥ÄÎêú Episodes, Nodes, ChoicesÎäî cascadeÎ°ú ÏûêÎèô ÏÇ≠Ï†úÎê®)
        log.info("Deleting StoryCreation: {}", storyId);
        storyCreationRepository.delete(storyCreation);

        log.info("Story deleted successfully: {}", storyId);
    }

    /**
     * Ïä§ÌÜ†Î¶¨ÏôÄ Ïó∞Í¥ÄÎêú S3 ÌååÏùºÎì§ ÏÇ≠Ï†ú
     */
    private void deleteS3FilesForStory(StoryCreation storyCreation) {
        log.info("Deleting S3 files for story: {}", storyCreation.getId());

        // ÏÜåÏÑ§ ÏõêÎ≥∏ ÌååÏùº
        if (storyCreation.getS3FileKey() != null) {
            deleteS3File(storyCreation.getS3FileKey(), "Novel original");
        }

        // Î∂ÑÏÑù Í≤∞Í≥º ÌååÏùº
        if (storyCreation.getAnalysisResultFileKey() != null) {
            deleteS3File(storyCreation.getAnalysisResultFileKey(), "Analysis result");
        }

        // ÎÖ∏Îìú Ïù¥ÎØ∏ÏßÄ ÌååÏùºÎì§ ÏÇ≠Ï†ú
        try {
            List<com.story.game.story.entity.Episode> episodes = episodeRepository.findAllByStory(storyCreation);
            int imageCount = 0;

            for (com.story.game.story.entity.Episode episode : episodes) {
                for (com.story.game.story.entity.StoryNode node : episode.getNodes()) {
                    if (node.getImageFileKey() != null && !node.getImageFileKey().isBlank()) {
                        deleteS3File(node.getImageFileKey(), "Node image");
                        imageCount++;
                    }
                }
            }

            log.info("Deleted {} node images for story: {}", imageCount, storyCreation.getId());
        } catch (Exception e) {
            log.warn("Failed to delete some node images (non-critical): {}", storyCreation.getId(), e);
        }
    }

    /**
     * S3 ÌååÏùº ÏÇ≠Ï†ú (Ïã§Ìå®Ìï¥ÎèÑ Î°úÍ∑∏Îßå ÎÇ®Í∏∞Í≥† Í≥ÑÏÜç ÏßÑÌñâ)
     */
    private void deleteS3File(String fileKey, String fileType) {
        try {
            s3Service.deleteFile(fileKey);
            log.info("Deleted {} from S3: {}", fileType, fileKey);
        } catch (Exception e) {
            log.warn("Failed to delete {} from S3: {} (continuing anyway)", fileType, fileKey, e);
        }
    }

    /**
     * Ïç∏ÎÑ§Ïùº Ï°∞Ìöå
     */
    @Transactional(readOnly = true)
    public ThumbnailResponseDto getThumbnail(String storyId) {
        log.info("=== Get Thumbnail ===");
        log.info("StoryId: {}", storyId);

        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new com.story.game.common.exception.ResourceNotFoundException("Story not found: " + storyId));

        String thumbnailUrl = null;
        boolean hasAiGenerated = false;

        if (storyCreation.getThumbnailFileKey() != null && !storyCreation.getThumbnailFileKey().isBlank()) {
            try {
                thumbnailUrl = s3Service.generatePresignedDownloadUrl(storyCreation.getThumbnailFileKey());
                hasAiGenerated = true;  // Ïç∏ÎÑ§ÏùºÏù¥ ÏûàÏúºÎ©¥ AI ÏÉùÏÑ± ÎòêÎäî ÏÇ¨Ïö©Ïûê ÏóÖÎ°úÎìúÎ°ú Í∞ÑÏ£º
                log.info("Generated thumbnail URL for story: {}", storyId);
            } catch (Exception e) {
                log.warn("Failed to generate thumbnail URL for story {}: {}", storyId, e.getMessage());
            }
        } else {
            log.info("No thumbnail available for story: {}", storyId);
        }

        return ThumbnailResponseDto.builder()
                .thumbnailUrl(thumbnailUrl)
                .hasAiGenerated(hasAiGenerated)
                .build();
    }

    /**
     * ÏÇ¨Ïö©ÏûêÍ∞Ä ÏßÅÏ†ë ÏóÖÎ°úÎìúÌïú Ïç∏ÎÑ§ÏùºÎ°ú ÍµêÏ≤¥
     * AI ÏÉùÏÑ± Ïã§Ìå® ÎòêÎäî ÏÇ¨Ïö©ÏûêÍ∞Ä ÏõêÌïòÎäî Ïù¥ÎØ∏ÏßÄÎ°ú Î≥ÄÍ≤ΩÌï† Îïå ÏÇ¨Ïö©
     */
    @Transactional
    public ThumbnailUploadResponseDto uploadThumbnail(String storyId, ThumbnailUploadRequestDto request, com.story.game.auth.entity.User user) {
        log.info("=== Upload Custom Thumbnail ===");
        log.info("StoryId: {}, ThumbnailFileKey: {}, User: {}", storyId, request.getThumbnailFileKey(), user.getUsername());

        // Find story
        StoryCreation storyCreation = storyCreationRepository.findById(storyId)
                .orElseThrow(() -> new com.story.game.common.exception.ResourceNotFoundException("Story not found: " + storyId));

        // Authorization check
        if (storyCreation.getUser() == null || !storyCreation.getUser().getId().equals(user.getId())) {
            throw new com.story.game.common.exception.UnauthorizedException("Unauthorized: Not the story owner");
        }

        // Update thumbnail file key
        String oldThumbnailFileKey = storyCreation.getThumbnailFileKey();
        storyCreation.setThumbnailFileKey(request.getThumbnailFileKey());
        storyCreationRepository.save(storyCreation);

        log.info("Updated thumbnail fileKey from {} to {}", oldThumbnailFileKey, request.getThumbnailFileKey());

        // Generate presigned download URL
        String thumbnailUrl = s3Service.generatePresignedDownloadUrl(request.getThumbnailFileKey());

        return ThumbnailUploadResponseDto.builder()
                .thumbnailUrl(thumbnailUrl)
                .message("Thumbnail uploaded successfully")
                .build();
    }
}