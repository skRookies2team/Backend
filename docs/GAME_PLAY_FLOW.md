# Game Play Flow

이 문서는 사용자가 완성된 인터랙티브 스토리를 플레이하는 전체 과정을 설명합니다.

## 아키텍처 구성 요소

-   **User (Player)**: 스토리를 플레이하는 사용자. 프론트엔드 UI를 통해 시스템과 상호작용합니다.
-   **Backend (Spring Boot)**: 게임 플레이 로직, 사용자 세션 관리, DB 연동을 담당합니다.
-   **MariaDB**: 플레이할 스토리의 모든 구조(에피소드, 노드, 선택지, 엔딩)를 저장하고 있는 데이터베이스입니다.

## 플레이 흐름도 (Step-by-Step)

1.  **스토리 선택 (Story Selection)**
    -   사용자가 프론트엔드에 표시된 스토리 목록에서 플레이할 스토리를 선택합니다.
    -   프론트엔드는 백엔드에 게임 플레이 시작을 요청합니다. (`POST /api/gameplay/start/{storyId}`)

2.  **게임 세션 초기화 (Session Initialization)**
    -   백엔드의 `GameplayService`는 해당 사용자와 스토리에 대한 새로운 플레이 세션을 생성합니다.
    -   이 세션은 사용자의 현재 위치(current node), 캐릭터와의 관계 수치(gauges), 진행 상황 등을 추적하는 데 사용됩니다.

3.  **첫 노드 로드 및 제시 (Load & Present First Node)**
    -   백엔드는 **MariaDB**에서 해당 스토리의 첫 번째 에피소드에 있는 시작 `StoryNode`를 조회합니다.
    -   조회한 노드의 텍스트 내용, 관련 미디어(이미지 등), 그리고 해당 노드에 연결된 `StoryChoice`(선택지) 목록을 프론트엔드에 전달합니다.
    -   프론트엔드는 이 정보를 사용자에게 시각적으로 보여줍니다.

4.  **사용자 선택 (Player Makes a Choice)**
    -   사용자는 제시된 선택지 중 하나를 고릅니다.
    -   프론트엔드는 사용자가 선택한 `StoryChoice`의 ID를 백엔드에 전송합니다. (`POST /api/gameplay/choose`)

5.  **선택 처리 및 다음 노드 탐색 (Process Choice & Find Next Node)**
    -   백엔드는 전달받은 `choiceId`를 이용해 **MariaDB**에서 해당 `StoryChoice` 정보를 조회합니다.
    -   조회된 선택지 정보에는 다음에 보여줄 `next_node_id`가 포함되어 있습니다.
    -   선택에 따른 수치(gauge) 변경이 있다면, 현재 플레이 세션에 반영합니다.

6.  **다음 노드 로드 및 제시 (Load & Present Next Node)**
    -   백엔드는 `next_node_id`를 사용하여 **MariaDB**에서 다음 `StoryNode`의 정보를 조회합니다.
    -   **`Step 3`**의 과정과 동일하게, 새로운 노드의 정보와 그에 따른 선택지들을 프론트엔드에 전달하여 사용자에게 보여줍니다.

7.  **엔딩 확인 및 흐름 제어 (Check Ending & Control Flow)**
    -   만약 `next_node_id`가 특정 에피소드의 끝을 의미하는 `EpisodeEnding`이나 스토리 전체의 끝을 의미하는 `FinalEnding`을 가리키는 경우, 백엔드는 이를 감지합니다.
    -   백엔드는 해당 엔딩 정보를 프론트엔드에 전달하고, 게임 플레이 세션을 종료하거나 다음 에피소드로 넘어가는 등의 후속 처리를 진행합니다.
    -   엔딩이 아니라면, 사용자가 다시 선택을 할 때까지 대기하며 **`Step 4`**부터의 과정을 반복합니다.

이처럼 게임 플레이는 '노드 제시 -> 사용자 선택 -> 다음 노드 제시'의 사이클을 통해 스토리가 진행되며, 사용자의 선택이 다음 전개에 직접적인 영향을 미치는 구조입니다.
